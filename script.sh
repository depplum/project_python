#!/bin/bash

while [ -n "$1" ] # пока существует первый аргумент
do
case "$1" in # если аргумент равен -d, -a, -c, то переменной присваиваем следующее значение
-d) directory=$2 ;; # директория
-a) action=$2 ;; # change или access - изменение файла или просмотр
-c) count=$2 ;; # вывести первые n
esac
shift # сдвигаем аргументы, удаляя первый
done

function main {
    if ! [ -d $1 ] # проверяем существует ли директория
    then
    echo 'Ошибка! Указанный путь это не директория или ее не существует'
    return # в таком случае завершаем выполнение
    fi

    re='^[0-9]+$' # регулярное выражение для проверки на число
    if ! [[ $3 =~ $re ]] # проверяем является ли count числом
    then
    echo "Ошибка! Аргумент -c должен быть целым числом"
    return # в таком случае завершаем выполнение
    fi

    cd "$1" # переходим в указанную директорию

    if [[ "$action" == "change" ]] # если выбрано изменение файла
    then 
    find . -type f -printf '%T@ %p\n' > files.txt # для всех файлов находим время изменения и записываем их вместе в файл
    cat files.txt | sort -r -n | head -$3 | cut -f2- -d" " # получаем все из этого файла, сортируем по убыванию(-r по убыванию, -n по числу), потом берем первые count элементов и берем второе значение в строке, т.е само название
    elif [[ "$action" == "access" ]] # если выбрано чтение файла
    then 
    find . -type f -printf '%A@ %p\n' > files.txt # для всех файлов находим время чтения и записываем их вместе в файл
    cat files.txt | sort -r -n | head -$3 | cut -f2- -d" " # получаем все из этого файла, сортируем по убыванию(-r по убыванию, -n по числу), потом берем первые count элементов и берем второе значение в строке, т.е само название
    else # если не указан верный режим, выводим ошибку
    echo "Ошибка! Не указано действие или указано неверно. Укажите -a change либо access"
    fi
}

main $directory $action $count # запускаем функцию с аргументами, которые мы получили вначале

# ./script.sh -d [path/to/dir] -a [access or change] -c [the first n]